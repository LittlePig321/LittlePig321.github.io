<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>(译)ES6 Cool stuffs — A big fat Arrow | little pig</title>
<link rel="shortcut icon" href="https://LittlePig321.github.io/favicon.ico?v=1565882087542">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://LittlePig321.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


    <link href="https://fonts.googleapis.com/icon?family=Material+Icons"
          rel="stylesheet">
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="post-detail">
          <a href="https://LittlePig321.github.io" class="backHome">
            <i class="material-icons md-48 backIcon">keyboard_arrow_left</i>&nbsp;<span style="vertical-align: middle">BACK HOME</span>
          </a>

          <article class="post">
            <h2 class="post-title">
              (译)ES6 Cool stuffs — A big fat Arrow
            </h2>
            <div class="post-infos">
              <time>Published 2019-06-28</time>
              
            </div>
            
              <div class="post-feature-image" style="background-image: url('https://LittlePig321.github.io/post-images/es6-cool-stuffs-a-big-fat-arrow.png')">
              </div>
            
            <div class="post-content">
              <p>Yup, 如果输入是一罐可乐, 返回值就是一只肥胖的独角兽. 听起来很符合逻辑, 不是么? 😄</p>
<p>箭头函数被认为是 ES6 中最出色的特征之一. 你是否曾想过为什么以及如何使用它? 如果你曾想过, 这篇文章再适合你不过了. 让我们开始踏上了解箭头函数表达式的旅途吧.</p>
<p>照例, 让我们简要介绍一下关于js中函数的旧概念.</p>
<h2 id="js-中的函数">JS 中的函数</h2>
<p>每一个 JS 函数(ES6 之前)都可通过 <code>function</code> 操作符语法声明:</p>
<pre><code>function HelloWorld() {console.log('Hello World')}
HelloWorld()
</code></pre>
<p>或者可以在<code>表达式</code>里通过 <code>function</code> 关键字声明为<code>非方法函数</code>(non-method function)</p>
<pre><code>let sayHello = function() {console.log('Hi there')}
</code></pre>
<p>或者使用带有<code>new</code>语法的函数构造器</p>
<pre><code>let sayHello = new Function(`console.log('Hello World');`);
sayHello(); //'Hello World';
</code></pre>
<p>提醒: Function 是一个全局范围的对象. 实际上,  完全不建议使用 Function 构造器来定义函数, 因为类似于 eval 的性能问题. 为什么会这样呢? 因为..</p>
<blockquote>
<p>每次对<code>源代码字符串</code>调用 eval 或者 Function 时, 脚本引擎必须启动将源代码转换为可执行代码的机制.</p>
</blockquote>
<p>所以, 代价是沉重的! 毕竟我们都知道 eval 等于 <em><code>eval</code></em>, 不是么? 😄</p>
<p>然而, <code>function</code> 可以被用作构造器来实现 面向对象的原型继承. 是不是听起来很熟悉? 确实, 我们就是这样做, 直到 <code>class</code> 被介绍.</p>
<p>简而言之, 定义或声明函数最经典的做法是非常简单的. 因此产生了一个问题: 为什么我们需要另一些额外的方法来实现它? 是因为我们想让js变得更复杂来吓跑新手么?</p>
<p>Well, 当然不是. 为了回答这个问题, 让我们仔细看看新功能, 好么?</p>
<h2 id="箭头函数表达式">箭头函数表达式</h2>
<h3 id="基本">基本</h3>
<p><code>=&gt;</code>, 或者 &quot;fat&quot; 表达式, 灵感来源于 <code>CoffeeScript</code> 的箭头, 与经典的 function 表达式相比, 它更新, 更短, 更简洁的语法(不那么冗长). 基本语法格式如下:</p>
<pre><code>// servel parameters
(param1, param2, ... paramN) =&gt; { // statement }

// No parameter
() =&gt; { // statement }
</code></pre>
<p>上面的代码可被复写成:</p>
<pre><code>let HelloWorld = () =&gt; { console.log('Hello World') }
</code></pre>
<p>笔记:</p>
<ul>
<li>在参数定义 <code>()</code> 和 <code>=&gt;</code> 之间没有换行</li>
</ul>
<pre><code>let sumUp = (a, b) =&gt; a + b //OK
let sumUp = (a, b) =&gt; a + b //OK

let sumUp = (a, b)
=&gt; a + b //NOT OK

let sumUp = (a, b) =&gt;
a + b //OK
</code></pre>
<ul>
<li>如果函数里只有一条代码, 我们可以去掉 <code>{}</code> 使得代码更简短:</li>
</ul>
<pre><code>let HelloWorld = () =&gt; console.log('Hello World')
</code></pre>
<ul>
<li>如果只包含 <code>return</code> 语句, 我们也可以去掉 return</li>
</ul>
<pre><code>let sayMyName = () =&gt; `Maya Shavin`
sayMyName() //&quot;Maya Shavin&quot;
</code></pre>
<p><strong>箭头函数带来的一些问题</strong>: 当你的简写箭头函数返回值为一个对象时，你需要用小括号括起你想返回的对象。否则，浏览器会把对象的<code>{}</code>解析为箭头函数函数体的开始和结束标记。</p>
<pre><code>[1, 2, 3].map(value =&gt; { number: value })
// &lt;- [undefined, undefined, undefined]

[1, 2, 3].map(value =&gt; { number: value, verified: true })
// &lt;- SyntaxError

// 正确的使用形式
var objectFactory = () =&gt; ({ modular: 'es6' })
</code></pre>
<ul>
<li>如果这里只有一个参数, 我们可以去掉参数外的圆括弧</li>
</ul>
<pre><code>let printName = name =&gt; console.log(name)
</code></pre>
<p>太棒了, 还有其他更有趣的么?</p>
<h3 id="绑定this">绑定<code>this</code></h3>
<p>让我们先来看下面一个例子:</p>
<pre><code>let WaitAndSee = {
		counter: 1,
		wait: function(){
				let numbers = [1,2,3,4]
				numbers.map(function(x) {
						// 这里的 this, 指向 window
						 this.counter++
				})
		},
		see: function(){
				console.log(`Counter: ${this.counter}`)
				console.log(`Window counter: ${window.counter}`)
		}
}
</code></pre>
<p>在下面的代码中将会发生什么?</p>
<pre><code>window.counter = 1
WaitAndSee.wait()
WaitAndSee.see()
</code></pre>
<p>很经典, 不是么? 当在非严格模式下, 只有 window 的 counter 将会被更新. 是不是感觉很困惑? 确实, <strong>因为对于传统 function, this 由函数的调用方式动态决定的</strong>. 为了克服这个问题, 需要一种<strong>技巧</strong>: 把 <code>this</code> 赋值给一个变量, 通常命名为 <code>self</code>, <code>that</code>等等. 或者我们也可以用 <code>Function.prototype.bind()</code> 来确保 this 被正确绑定. 然而, 这两种方法都不足以让我们的开发人员的工作更轻松.</p>
<p>幸运的是, 箭头函数不要定义自己的 this, this 的值由使用箭头函数的外部范围决定.因此, 如果你希望得到正确的 this, 仅仅需要确保:</p>
<ul>
<li>通过适当的语法触发非箭头函数, 以便从调用者那里接收有意义的 this 值.</li>
<li>其他的都用箭头函数</li>
</ul>
<p>所以上面的例子, 可以写成如下:</p>
<pre><code>let WaitAndSee = {
		counter: 1,
		wait: function(){
				let numbers = [1,2,3,4]
				numbers.map(x =&gt; this.counter++)
		},
		see: function(){
				console.log(this.counter)
		}
}
WaitAndSee.wait()
WaitAndSee.see() //5
</code></pre>
<h3 id="箭头函数没有arguments对象">箭头函数没有'arguments'对象</h3>
<p>记得函数的 arguments 参数么?</p>
<p><img src="https://LittlePig321.github.io/post-images/1561700278880.png" alt=""></p>
<p>然而, 不幸(或者幸运)的是:没有为箭头函数明确定义 arguments.</p>
<pre><code>let showArguments = () =&gt; console.log(arguments)
showArguments() //ReferenceError: arguments is not defined
</code></pre>
<p>相反, 如果你还是希望获得一样的效果,如arguments, 可以使用 <code>...</code> 语法作为 rest 参数是一个很好的选择.</p>
<pre><code>let showArguments = (...arguments) =&gt; console.log(arguments)
showArguments() //[]
</code></pre>
<blockquote>
<p>需要主要注意的: rest 参数 与 arguments 对象不一样, 因为它是一个具有完整数组功能的数组实例, 而 arguments 只是一个类似数组的对象(array-like object).</p>
</blockquote>
<h3 id="箭头函数用作构造器">箭头函数用作构造器?</h3>
<p>根据定义, 箭头函数是函数表达式类型, 因此, 它不能用作函数的声明.</p>
<pre><code>function WaitAndSee(){...} //OK
let WaitAndSee = () =&gt; {} //OK
WaitAndSee() =&gt; {} //Wrong syntax
</code></pre>
<p>而且它不能为了面向对象继承而被用作构造器, 是的, 也意味着 new 语法不能和它一起使用.</p>
<blockquote>
<p>当然, 它没有<code>原型</code>!!!</p>
</blockquote>
<p>Oh, 不要想当然的在箭头函数内部使用 super(), 它根本不会像你期望的那样有用.</p>
<h3 id="非方法函数non-method-function">非方法函数(Non-method function)</h3>
<p>理论上, 箭头函数可以被用作方法函数(method function), 然而, 这是<strong>完全不推荐的</strong>. 由于它没有自己的 this. 如果把它用作method function 可能导致意想不到的行为并造成不想要的bug, 不要感到惊讶. 比如:</p>
<pre><code>let WaitAndSee = {
		counter: 1,
		wait: () =&gt; { this.counter++ },
		see: function(){
				console.log(`Counter: ${this.counter}`)
				console.log(`Window counter: ${window.counter}`)
		}
}

window.counter = 1
WaitAndSee.wait()  // 1
WaitAndSee.see()   // 2  window.counter is updated instead!
</code></pre>
<blockquote>
<p>什么是 <code>non-method functions</code> 呢？对象属性中的函数就被称之为 method，那么 non-mehtod 就是指不被用作对象属性中的函数了.</p>
</blockquote>
<p>到目前为止还算 OK? great, 让我们回到我们的原始问题: 使用箭头函数的好处是什么?</p>
<h2 id="益处">益处</h2>
<p>使用箭头函数最明显的益处是更简短和更少冗余的语法. 老实告诉我, 你有没有打字太快而打错了 function 成 fucntion 甚至 fucntoin? 我干过!! 因此当我需要敲很多代码的时候,箭头函数绝对是我的救世主.</p>
<p>另一方面, <strong>一个重要的益处是 this 的词法绑定, 值取决于其周围的范围，而不是如何调用它</strong>.</p>
<p>这种改进确实简化函数范围, 避免大量不必要的bug, 从而减少了解决方案修复所需的代码量.毕竟, 当你有一个更好的选择, 谁会想写 <code>Object.method.bind(this)</code>.</p>
<p>这就是 ES6 箭头函数的主要好处.  那不足/缺点呢? 让我们找出它们.</p>
<h2 id="弊端">弊端</h2>
<p>正如一些程序员可能会说的, 有时代码越少不意味着更好的可读性. 因此, 更短的语法也可以说是它的缺点, 太短会造成混淆, 比如:</p>
<pre><code>let getMyName = () =&gt; `Maya Shavin`
</code></pre>
<p>第一印象, 对于不熟悉 coffeeScript 语法的程序员来理解这个函数会返回一个字符串是有点困难的. 当我们想返回一些东西的时候, 我们都使用 return 语法, 是吧?</p>
<p>第二, 箭头 <code>=&gt;</code> 表达式是相当松散的绑定, 也被称为: 在某种情况, 与其他操作符有冲突时, 通常 <code>=&gt;</code> 将首先丢失. 因此开发人员在使用它时需要更加小心.</p>
<p>最后, 箭头函数不能用做构造器. 想干, 我们使用 class 作为函数构造器的替代.</p>
<h2 id="结论">结论</h2>
<p>如我在其他文中所述, ES6 大多数特征仅仅是函数表达式的语法糖. 箭头函数也不例外, 与经典函数相比, 在性能方面几乎没有显著的改进.</p>
<p>对我来说,它最重要的益处是对于 <code>this 范围绑定</code>提供了一个更短更精干的解决方案. 最终, 开发者可以享受这种干净, 更优雅和更少的工作代码.</p>
<p>但是, 不要仅仅因为它的酷和益处而使用它. 为了编写好的代码, 你总是需要了解用例和特征陷阱.</p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://LittlePig321.github.io/post/what-is-the-cost-of-lies">
              <h3 class="post-title">
                what is the cost of lies?
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/LittlePig321" target="_blank">LittlePig</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
